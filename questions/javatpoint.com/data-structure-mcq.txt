&[Index: 0
Question: How can we describe an array in the best possible way?
CodeBlock:

Options:
0 . the array shows a hierarchical structure.
1 . arrays are immutable.
2 . container that stores the elements of similar types
3 . the array is not a data structure
4 . 
Correct Answer: 2

Explanation: The answer is c because array stores the elements in a contiguous block of memory of similar types. Therefore, we can say that array is a container that stores the elements of similar types.

 Index: 1
Question: Which of the following is the correct way of declaring an array?
CodeBlock:

Options:
0 . int javatpoint[10];
1 . int javatpoint;
2 . javatpoint{20};
3 . array javatpoint[10];
4 . 
Correct Answer: 0

Explanation: The answer is a because int specifies the type of the array, javatpoint is the name of the array, and 10 is the size of the array enclosed within the square brackets.

 Index: 2
Question: How can we initialize an array in C language?
CodeBlock:

Options:
0 . int arr[2]=(10, 20)
1 . int arr(2)={10, 20}
2 . int arr[2] = {10, 20}
3 . int arr(2) = (10, 20)
4 . 
Correct Answer: 2

Explanation: The answer is c because the values assigned to the array must be enclosed within a curly bracket.

 Index: 3
Question: Which of the following is the advantage of the array data structure?
CodeBlock:

Options:
0 . elements of mixed data types can be stored.
1 . easier to access the elements in an array
2 . index of the first element starts from 1.
3 . elements of an array cannot be sorted
4 . 
Correct Answer: 1

Explanation: The answer is b because the elements in an array are stored in a contiguous block of memory, so it is easier to access the elements of an array through indexing.

 Index: 4
Question: Which of the following highly uses the concept of an array?
CodeBlock:

Options:
0 . binary search tree
1 . caching
2 . spatial locality
3 . scheduling of processes
4 . 
Correct Answer: 2

Explanation: The answer is c, i.e., Spatial locality. Here, spatial locality means that the instruction accessed recently, then the nearby memory location would be accessed in the next iteration. As we know that in an array, all the elements are stored in a contiguous block of memory, so spatial locality is accessed quickly.

 Index: 5
Question: Which of the following is the disadvantage of the array?
CodeBlock:

Options:
0 . stack and queue data structures can be implemented through an array.
1 . index of the first element in an array can be negative
2 . wastage of memory if the elements inserted in an array are lesser than the allocated size
3 . elements can be accessed sequentially.
4 . 
Correct Answer: 2

Explanation: The answer is c. For example, if we have an array of size 10 elements and we have inserted only 5 elements in an array then there is a wastage of 5 memory blocks which cannot be utilized by another variable.

 Index: 6
Question: What is the output of the below code?
CodeBlock:
#include <stdio.h>
int main()
{
   int arr[5]={10,20,30,40,50};
   printf("%d", arr[5]);

    return 0;
}

Options:
0 . garbage value
1 . 10
2 . 50
3 . none of the above
4 . 
Correct Answer: 0

Explanation: The answer is a because the indexing in an array starts from 0, so it starts from arr[0] to arr[4]. If we try to access arr[5] then the garbage value will be printed.

 Index: 7
Question: Which one of the following is the size of int arr[9] assuming that int is of 4 bytes?
CodeBlock:

Options:
0 . 9
1 . 36
2 . 35
3 . none of the above
4 . 
Correct Answer: 1

Explanation: The answer is b because the size of int type data is 4 bytes. The array stores 9 elements, so the size of the array is 9*4=36 bytes.

 Index: 8
Question: Which one of the following is the process of inserting an element in the stack?
CodeBlock:

Options:
0 . insert
1 . add
2 . push
3 . none of the above
4 . 
Correct Answer: 2

Explanation: The answer is c. In stack, the process of inserting an element is known as a push operation.

 Index: 9
Question: When the user tries to delete the element from the empty stack then the condition is said to be a ____
CodeBlock:

Options:
0 . underflow
1 . garbage collection
2 . overflow
3 . none of the above
4 . 
Correct Answer: 0

Explanation: The answer is a. Underflow is a condition that occurs when user tries to implement the pop operation in the empty stack.

 Index: 10
Question: If the size of the stack is 10 and we try to add the 11th element in the stack then the condition is known as___
CodeBlock:

Options:
0 . underflow
1 . garbage collection
2 . overflow
3 . none of the above
4 . 
Correct Answer: 2

Explanation: The answer is c because the stack is full with its 10 elements, and inserting one more element in a stack will lead to the stack overflow.

 Index: 11
Question: Which one of the following is not the application of the stack data structure
CodeBlock:

Options:
0 . string reversal
1 . recursion
2 . backtracking
3 . asynchronous data transfer
4 . 
Correct Answer: 3

Explanation: The answer is d. The first three options are the stack applications, but option d is not a stack application. The queue data structure is used for synchronization between the processes.

 Index: 12
Question: Which data structure is mainly used for implementing the recursive algorithm?
CodeBlock:

Options:
0 . queue
1 . stack
2 . binary tree
3 . linked list
4 . 
Correct Answer: 1

Explanation: The answer is b. Recursion means calling the function itself again. Stack is used to maintain the previous records of the function.

 Index: 13
Question: Which data structure is required to convert the infix to prefix notation?
CodeBlock:

Options:
0 . stack
1 . linked list
2 . binary tree
3 . queue
4 . 
Correct Answer: 0

Explanation: The answer is a, i.e., stack. Stack is a data structure used to reverse the order of the operators in the expression. It is also used as a storage structure that stores all the operators and print all the operators when all the operands have appeared.

 Index: 14
Question: Which of the following is the infix expression?
CodeBlock:

Options:
0 . a+b*c
1 . +a*bc
2 . abc+*
3 . none of the above
4 . 
Correct Answer: 0

Explanation: The answer is a, i.e., A+B*C because, in infix notation, all the operators appear between the operands.

 Index: 15
Question: Which of the following is the prefix form of A+B*C?
CodeBlock:

Options:
0 . a+(bc*)
1 . +ab*c
2 . abc+*
3 . +a*bc
4 . 
Correct Answer: 3

Explanation: The answer is d. The prefix notation means all the operators that appear before operand.To convert the infix expression into a prefix expression, we will move the operator to the left of the parenthesis as shown in the below figure.

 Index: 16
Question: Which of the following is not the correct statement for a stack data structure?
CodeBlock:

Options:
0 . arrays can be used to implement the stack
1 . stack follows fifo
2 . elements are stored in a sequential manner
3 . top of the stack contains the last inserted element
4 . 
Correct Answer: 1

Explanation: The answer is b because Stack does not follow FIFO. It follows LIFO.

 Index: 17
Question: If the elements '1', '2', '3' and '4' are added in a stack, so what would be the order for the removal?
CodeBlock:

Options:
0 . 1234
1 . 2134
2 . 4321
3 . none of the above
4 . 
Correct Answer: 2

Explanation: The answer is c because stack follows LIFO, which means that the element inserted at the last will be removed first.

 Index: 18
Question: What is the outcome of the prefix expression +, -, *, 3, 2, /, 8, 4, 1?
CodeBlock:

Options:
0 . 12
1 . 11
2 . 5
3 . 4
4 . 
Correct Answer: 2

Explanation: Reverse of the prefix expression: 1, 4, 8, /, 2, 3, *, -, +

Reading of prefix
Top of the stack
Stack representation


1
1



4
4



8
8



/
(8/4)



2
2



3
3



*
(2*3)



-
(2*3) - (8/4)



+
(2*3) - (8/4) +1


The infix expression of the above prefix expression is:(2*3) - (8/4) +16 -2 +1 = 5

 Index: 19
Question: The minimum number of stacks required to implement a stack is __
CodeBlock:

Options:
0 . 1
1 . 3
2 . 2
3 . 5
4 . 
Correct Answer: 2

Explanation: The answer is 2. In Queue, one stack is required for the enqueue operation, and another stack will be used for the dequeue operation. The first stack is considered as the input stack whereas the second stack is considered as the output stack.

 Index: 20
Question: Which one of the following node is considered the top of the stack if the stack is implemented using the linked list?
CodeBlock:

Options:
0 . first node
1 . second node
2 . last node
3 . none of the above
4 . 
Correct Answer: 0

Explanation: The answer is a, i.e., First node. As we know, that last inserted element in the stack is considered as the top of the stack. Whenever the element is added to the linked list, it is always added at the beginning of the list. Therefore, we can say that the first node in the linked list is considered as the top of the stack.

 Index: 21
Question: Consider the following stack implemented using stack.
CodeBlock:
#define SIZE 11
struct STACK
{
   int arr[SIZE];
   int top=-1; 
}

Options:
0 . 8
1 . 9
2 . 11
3 . 10
4 . 
Correct Answer: 3

Explanation: The answer is 10. The maximum size of the array is 11; therefore, we can insert 11 elements in the stack. The top value is initialized by -1, and on every insertion, the top value gets incremented.

 Index: 22
Question: What is another name for the circular queue among the following options?
CodeBlock:

Options:
0 . square buffer
1 . rectangle buffer
2 . ring buffer
3 . none of the above
4 . 
Correct Answer: 2

Explanation: The circular queue is also known as a ring buffer. In a circular queue, the last element is connected back to the first element of the queue that forms a circle. Therefore, the structure of a circular queue is also known as a ring structure.

 Index: 23
Question: If the elements '1', '2', '3' and '4' are inserted in a queue, what would be order for the removal?
CodeBlock:

Options:
0 . 1234
1 . 4321
2 . 3241
3 . none of the above
4 . 
Correct Answer: 0

Explanation: The answer is a, i.e., 1234. The queue follows the FIFO principle in which the element inserted first will be removed first.

 Index: 24
Question: A list of elements in which enqueue operation takes place from one end, and dequeue operation takes place from one end is__
CodeBlock:

Options:
0 . binary tree
1 . stack
2 . queue
3 . linked list
4 . 
Correct Answer: 2

Explanation: The answer is Queue. Queue is a data structure in which insertion takes place from one end, and deletion takes place from one end.

 Index: 25
Question: Which of the following principle does Queue use?
CodeBlock:

Options:
0 . lifo principle
1 . fifo principle
2 . linear tree
3 . ordered array
4 . 
Correct Answer: 1

Explanation: The answer is FIFO principle. Here, FIFO stands for First-In-First-Out. It means that the element which is inserted first will also be removed first.

 Index: 26
Question: Which one of the following is not the type of the Queue?
CodeBlock:

Options:
0 . linear queue
1 . circular queue
2 . double ended queue
3 . single ended queue
4 . 
Correct Answer: 3

Explanation: The answer is d. i.e., single ended queue. Queue has two ends in which one end is used for the insertion and another end is used for the deletion. Therefore, it is not possible for the Queue to have a single ended queue.

 Index: 27
Question: Which one of the following is the overflow condition if linear queue is implemented using an array with a size MAX_SIZE?
CodeBlock:

Options:
0 . rear = front
1 . rear = front+1
2 . rear=max_size -1
3 . rear = max_size
4 . 
Correct Answer: 2

Explanation: The answer is c, i.e., rear=MAX_SIZE-1. As the size of the array is MAX_SIZE, so we can insert the elements till MAX_SIZE-1. If we try to insert the elements of size MAX_SIZE or more than MAX_SIZE in a queue, then it leads to the overflow condition. 

 Index: 28
Question: Which one of the following is the overflow condition if a circular queue is implemented using array having size MAX?
CodeBlock:

Options:
0 . rear= max-1
1 . rear=max
2 . front=(rear+1) mod max
3 . none of the above
4 . 
Correct Answer: 2

Explanation: The answer is c, i.e., front=(rear+1) mod max. The overflow condition for the linear queue is rear =MAX-1 as there is no space left in the Queue if rear = MAX-1. On the other hand, in a circular queue, the overflow condition is front=(rear+1) mod max because the last element is connected to the first element in a circular queue.

 Index: 29
Question: The time complexity of enqueue operation in Queue is __
CodeBlock:

Options:
0 . o(1)
1 . o(n)
2 . o(logn)
3 . o(nlogn)
4 . 
Correct Answer: 0

Explanation: The answer is a, i.e., O(1). In Queue, the insertion is performed at the rear end, which is directly accessible; therefore, it takes O(1) time to insert an element in a Queue.

 Index: 30
Question: Which of the following that determines the need for the Circular Queue?
CodeBlock:

Options:
0 . avoid wastage of memory
1 . access the queue using priority
2 . follows the fifo principle
3 . none of the above
4 . 
Correct Answer: 0

Explanation: The answer is a, i.e., Avoid wastage of memory. In a linear queue, there are chances of wastage of memory because if the rear is pointing to the last element whereas the front is pointing to the element other than the first element; it means that spaces allocated before the front are free, but it cannot be reused as rear cannot be incremented. In contrast, the last element is connected to the first element in a circular queue; if initial spaces are vacant, then rear can be incremented by using the statement (rear+1) mod max where max is the size of the array. Therefore, we conclude that the circular queue avoids wastage of memory.

 Index: 31
Question: Which one of the following is the correct way to increment the rear end in a circular queue?
CodeBlock:

Options:
0 . rear =rear+1
1 . (rear+1) % max
2 . (rear % max) + 1
3 . none of the above
4 . 
Correct Answer: 1

Explanation: The answer is b. It ensures that the rear will have the value from 0 to max-1; if the rear end points to the last position, and we increment the rear end using (rear+1) % max, then rear will point to the first position in the queue.

 Index: 32
Question: Consider the following code.
CodeBlock:
int fun()
{
   if(isEmpty())
   {
      return -10; 
   }
  else
  {
     int n;
     n= q[front];
     front++;
     return n; 
  }
  
} 

Options:
0 . enqueue
1 . dequeue
2 . return the front element
3 . both b and c
4 . 
Correct Answer: 3

Explanation: The answer is d because two operations are performed in the above code. The first one is returning the value of the front with the help of the statement n=q[front], and the second operation is dequeue (deleting an element) by using the statement front++. 

 Index: 33
Question: In the linked list implementation of queue, where will the new element be inserted?
CodeBlock:

Options:
0 . at the middle position of the linked list
1 . at the head position of the linked list
2 . at the tail position of the linked list
3 . none of the above
4 . 
Correct Answer: 2

Explanation: The answer is c. If the queue is implemented using linked list, then the new element will be inserted at the tail position of the linked list as Queue follows FIFO principle in which new element will always be added at the end of the Queue.

 Index: 34
Question: How many Queues are required to implement a Stack?
CodeBlock:

Options:
0 . 3
1 . 2
2 . 1
3 . 4
4 . 
Correct Answer: 1

Explanation: The answer is b because one queue is required to perform the push operation while the other queue is used to perform the pop operation.

 Index: 35
Question: Which one of the following is not the application of the Queue data structure?
CodeBlock:

Options:
0 . resource shared between various systems
1 . data is transferred asynchronously
2 . load balancing
3 . balancing of symbols
4 . 
Correct Answer: 3

Explanation:The answer is d. The options a, b, and c are the applications of the Queue data structure while option d, i.e., balancing of symbols is not the application of the Queue data structure. The option a, i.e., resource shared between various system is the application of the Queue data structure as it allows to align all the requests for the resource in a queue. The option b, i.e., data is transferred asynchronously is a application of the Queue data structure. Here asynchronously means that the data received at the different rate as sent.The option c, i.e., load balancing is also an application of the Queue data structure because all the requests from the client are stored in the Queue, and it distributes the requests to the client one by one.The option d, i.e., balancing of symbols is an application of the stack data structure.

 Index: 36
Question: Which of the following option is true if implementation of Queue is from the linked list?
CodeBlock:

Options:
0 . in enqueue operation, new nodes are inserted from the beginning and in dequeue operation, nodes are removed from the end.
1 . in enqueue operation, new nodes are inserted from the end and in dequeue operation, nodes are deleted from the beginning.
2 . in enqueue operation, new nodes are inserted from the end and in dequeue operation, nodes are deleted from the end.
3 . both a and b
4 . 
Correct Answer: 3

Explanation: The answer is d. As we know that Queue has two ends, i.e., one for the insertion and another one for the deletion. If Queue is implemented using Linked list then it can be done in either of the ways.

 Index: 37
Question: The necessary condition to be checked before deletion from the Queue is__
CodeBlock:

Options:
0 . overflow
1 . underflow
2 . rear value
3 . front value
4 . 
Correct Answer: 1

Explanation: The answer is b, i.e., Underflow. Before deleting an element from the Queue, we first need to check whether the Queue is empty or not.

 Index: 38
Question: Which data structure is the best for implementing a priority queue?
CodeBlock:

Options:
0 . stack
1 . linked list
2 . array
3 . heap
4 . 
Correct Answer: 3

Explanation: The answer is d, i.e., Heap. All the data structures that are given in the above options can be used to implement a priority queue but the most efficient way of implementing a priority queue is heap data structure. 

 Index: 39
Question: Which of the following principle is used if two elements in the priority queue have the same priority?
CodeBlock:

Options:
0 . lifo
1 . fifo
2 . linear tree
3 . none of the above
4 . 
Correct Answer: 1

Explanation: The answer is b, i.e., FIFO. In a priority queue, if two or more elements have the same priority then they are arranged based on the FIFO principle.

 Index: 40
Question: Which of the following statement is not true regarding the priority queue?
CodeBlock:

Options:
0 . processes with different priority can be easily handled
1 . easy to implement
2 . deletion is easier
3 . none of the above
4 . 
Correct Answer: 2

Explanation: The answer is c. i.e., deletion is easier. In worst case, the deletion is not easier as we have to traverse to the n elements until the element to be removed is not found.

 Index: 41
Question: A linear data structure in which insertion and deletion operations can be performed from both the ends is___
CodeBlock:

Options:
0 . queue
1 . deque
2 . priority queue
3 . circular queue
4 . 
Correct Answer: 1

Explanation: The answer is b, i.e., Deque. The deque is a data structure in which both insertion and deletion can be performed from both the ends whereas, in Queue, insertion can be done from one end and deletion can be performed from another end.

 Index: 42
Question: In the Deque implementation using singly linked list, what would be the time complexity of deleting an element from the rear end?
CodeBlock:

Options:
0 . o(1)
1 . o(n2)
2 . o(n)
3 . o(nlogn)
4 . 
Correct Answer: 0

Explanation: The answer is O(n) because we need to traverse till the n element to delete the element from the rear end.

 Index: 43
Question: Which of the following data structure allows you to insert the elements from both the ends while deletion from only one end?
CodeBlock:

Options:
0 . input-restricted queue
1 . output-restricted queue
2 . priority queue
3 . none of the above
4 . 
Correct Answer: 1

Explanation: The answer is b. The output-restricted queue is one of the types of the Deque data structure in which insertion is allowed from both the ends but the deletion is allowed from only one end.

 Index: 44
Question: What would be the output after performing the following operations in a Deque?
CodeBlock:
Insertfront(10);
Insertfront(20);
Insertrear(30);
Insertrear(40);
Deletefront();
Insertfront(50);
Deleterear();
Display();

Options:
0 . 10, 20, 30
1 . 50, 10, 30
2 . 40, 20, 30
3 . none of the above
4 . 
Correct Answer: 1

Explanation:The answer is b.Let's dry run the above code.When insertfront(10) is called, deque would be:10When insertfront(20) is called, the deque would be:20 10When insertrear(30) is called, the deque would be:20 10 30When insertrear(40) is called, the deque would be:20 10 30 40When deletefront() is called, the deque would be:10 30 40When insertfront(50) is called, the deque would be:50 10 30 40When deleterear() is called, the deque would be:50 10 30

 Index: 45
Question: In a circular queue implementation using array of size 5, the array index starts with 0 where front and rear values are 3 and 4 respectively. Determine the array index at which the insertion of the next element will take place.
CodeBlock:

Options:
0 . 5
1 . 0
2 . 1
3 . 2
4 . 
Correct Answer: 1

Explanation: The answer is b, i.e., 0. As it is mentioned in the question that the size of the array is 5; therefore, the range would be from 0 to 4. In a circular queue, the last element is connected to the first element; the value of rear is 4 so when we increment the value then it will point to the 0th position of the array.

 Index: 46
Question: If circular queue is implemented using array having size MAX_SIZE in which array index starts with 0, front points to the first element in the queue, and rear points to the last element in the queue. Which one of the following conditions used to specify that the circular queue is empty?
CodeBlock:

Options:
0 . front=rear= -1
1 . front=rear=0
2 . front=rear+1
3 . none of the above
4 . 
Correct Answer: 0

Explanation: The answer is a, i.e., front=rear= -1. When the circular queue is empty means that no element is available in the queue then the front and rear are initialized with a -1 value. 

 Index: 47
Question: Consider the implementation of the singly linked list having the head pointer only in the representation. Which of the following operations can be performed in O(1) time?
CodeBlock:

Options:
0 . ii
1 . both ii and iii
2 . both i and iv
3 . both i and ii
4 . 
Correct Answer: 1

Explanation: The answer is b. As it is mentioned in the above question that there is only head pointer pointing to the front node in the list so it will take O(1) time to insert at the front as well as to delete the first node from the list. If we try to insert the node at the end or delete the last node then it will take O(n) time as we need to traverse till the n elements.

 Index: 48
Question: What would be the time complexity if user tries to insert the element at the end of the linked list (head pointer is known)?
CodeBlock:

Options:
0 . o(1)
1 . o(n)
2 . o(logn)
3 . o(nlogn)
4 . 
Correct Answer: 1

Explanation: The answer is b, i.e., O(n). As it is mentioned in the above question that head pointer is known, so to insert the node at the end of the linked list; we have to traverse till the nth node. Therefore, the time complexity would be O(n).

 Index: 49
Question: Which of the following is the time complexity to search an element in the linked list?
CodeBlock:

Options:
0 . o(1)
1 . o(n)
2 . o(logn)
3 . o(nlogn)
4 . 
Correct Answer: 0

Explanation: The answer is O(n). The worst-case time complexity to search an element in the linked list is O(n) because if we have to find the last element then we need to traverse till the nth node.

 Index: 50
Question: Consider the following code
CodeBlock:
struct node
{
   int data;
   struct node *next;
}
node ptr;

Options:
0 . ptr= (node*)malloc(sizeof(node*))
1 . ptr=(node)malloc(sizeof(node))
2 . ptr=(node*)malloc(sizeof(node))
3 . none of the above
4 . 
Correct Answer: 2

Explanation: The answer is c, i.e., ptr=(node*)malloc(sizeof(node)). In this statement, we have used a malloc() function for allocating the memory to the node and ptr is a pointer variable that will point to the newly created node.

 Index: 51
Question: Which of the following statement is not true about the doubly linked list?
CodeBlock:

Options:
0 . we can traverse in both the directions.
1 . it requires extra space
2 . implementation of doubly linked list is easier than the singly linked list
3 . it stores the addresses of the next and the previous node
4 . 
Correct Answer: 2

Explanation: The answer is c. The implementation of doubly linked list is complex as compared to singly linked list as it needs to store the addresses of the two nodes, i.e., the previous and the next node. If we insert or delete the node from the doubly linked list then it needs to adjust two pointers, previous and the next pointer.

 Index: 52
Question: What is the maximum number of children that a node can have in a binary tree?
CodeBlock:

Options:
0 . 3
1 . 1
2 . 4
3 . 2
4 . 
Correct Answer: 3

Explanation: The answer is d. The binary tree can contain utmost two children.

 Index: 53
Question: Which one of the following techniques is not used in the Binary tree?
CodeBlock:

Options:
0 . randomized traversal
1 . preorder traversal
2 . postorder traversal
3 . inorder traversal
4 . 
Correct Answer: 0

Explanation: The answer is a. The binary tree contains three traversal techniques, preorder, postorder and inorder traversal.

 Index: 54
Question: Which of the following options is not true about the Binary Search tree?
CodeBlock:

Options:
0 . the value of the left child should be less than the root node
1 . the value of the right child should be greater than the root node.
2 . the left and right sub trees should also be a binary search tree
3 . none of the above
4 . 
Correct Answer: 3

Explanation: The answer is d. All the three options, i.e., a, b and c are true for the binary search tree. In binary search tree, the left child should be less than the root node and the right child should be greater than the value of the root node.

 Index: 55
Question: How can we define a AVL tree?
CodeBlock:

Options:
0 . a tree which is binary search tree and height balanced tree.
1 . a tree which is a binary search tree but unbalanced tree.
2 . a tree with utmost two children
3 . a tree with utmost three children
4 . 
Correct Answer: 0

Explanation: The answer is a. An AVL tree is a binary search tree and height balanced tree.

 Index: 56
Question: Why do we prefer Red Black tree over AVL tree?
CodeBlock:

Options:
0 . red black trees are not strictly balanced
1 . red black tree requires lesser rotations than avl tree.
2 . avl tree needs more space to store the balance factor.
3 . both b and c
4 . 
Correct Answer: 3

Explanation: The answer is d. Red Black tree requires fewer rotations for inserting or deleting the node whereas AVL tree requires multiple rotations to balance the tree. AVL tree stores balance factor per node that requires space whereas Red Black tree stores 1-bit information.

 Index: 57
Question: Which of the following satisfies the property of the Red Black tree?
CodeBlock:

Options:
0 . a tree which is a binary search tree but not strictly balanced tree.
1 . a node must be either red or black in color and root node must be black.
2 . a tree with maximum three children
3 . both a and b
4 . 
Correct Answer: 3

Explanation: The answer is d. Red black tree is a binary search tree but it is not a strictly balanced tree like AVL tree. In Red Black tree, a node must be either in Black or Red in color and root node must be in Black color.

 Index: 58
Question: What would be the color of newly created node while inserting a new element in a Red black tree?
CodeBlock:

Options:
0 . black, if the new node is not a root node
1 . red, if the new node is not a root node
2 . black, if the new node is a root node
3 . both b and c
4 . 
Correct Answer: 3

Explanation: The answer is d. The property of Red Black tree is that if the newly created node is a root node then the color of the node would be Black otherwise the color of the node would be Red.

]